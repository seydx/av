name: 'ðŸ—ï¸ Build Prebuilds'

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  # Cache versions - increment when FFmpeg build configuration changes
  CACHE_VERSION_WINDOWS: 'v6'
  CACHE_VERSION_LINUX: 'v10'
  CACHE_VERSION_MACOS: 'v6'

on:
  workflow_dispatch:
  workflow_call:  # Allow this workflow to be called by other workflows
    secrets:
      NPM_TOKEN:
        required: false
        description: 'NPM token for publishing packages'
  # push:
  #   branches:
  #     - main
  #   paths-ignore:
  #     - '**/*.md'
  # pull_request:
  #   paths-ignore:
  #     - '**/*.md'

jobs:
  # Windows builds using MSYS2/Clang
  build_windows:
    name: 'Windows ${{ matrix.os.arch }}'
    runs-on: ${{ matrix.os.runner }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - name: CLANG64
            arch: x64
            runner: windows-latest
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - name: CLANGARM64
            arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    steps:
      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          # Important: path-type affects how paths are handled
          path-type: inherit
          install: >-
            git
            curl
            wget
            zip
            ${{ matrix.os.toolchain }}
            quilt
            diffstat
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-make
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-cmake
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-pkg-config
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-autotools

      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        shell: bash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare prefix dir
        run: |
          # Always create the directory structure with proper permissions
          # This is needed for both cache restore and fresh builds
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/include
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/bin

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: |
            C:\msys64\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\ffbuild
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-
          
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls ${PREFIX}/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d ${PREFIX}/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib} found" || echo "âœ— ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Run Jellyfin build script (builds all dependencies + FFmpeg)
          echo "Running build script: ${{ matrix.os.build_script }}"
          ${{ matrix.os.build_script }}
          
          # After build, libraries are in /clang*/ffbuild/lib/
          # Headers are in /clang*/ffbuild/include/
          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries in ${PREFIX}/lib: $(ls ${PREFIX}/lib/*.a 2>/dev/null | wc -l)"
          echo "Key codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d libsvtav1; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          
          # Also need FFmpeg's own libraries after make install
          make install
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls ${PREFIX}/jellyfin-ffmpeg/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          
          # Copy FFmpeg libraries to main lib directory for easier access
          cp ${PREFIX}/jellyfin-ffmpeg/lib/*.a ${PREFIX}/lib/ 2>/dev/null || true
          cp -r ${PREFIX}/jellyfin-ffmpeg/include/* ${PREFIX}/include/ 2>/dev/null || true
          
          # Also copy pkg-config files
          mkdir -p ${PREFIX}/lib/pkgconfig
          cp ${PREFIX}/jellyfin-ffmpeg/lib/pkgconfig/*.pc ${PREFIX}/lib/pkgconfig/ 2>/dev/null || true
          
          echo "=== Final library count: $(ls ${PREFIX}/lib/*.a | wc -l) ==="
          echo "=== Final header directories: $(ls -d ${PREFIX}/include/*/ | wc -l) ==="
          
          # Debug: Check what exists for cache
          echo "=== Checking cache paths ==="
          echo "MSYS2 path ${PREFIX} exists: $([ -d ${PREFIX} ] && echo 'YES' || echo 'NO')"
          echo "Windows path C:\\msys64\\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\\ffbuild exists:"
          ls -la "C:\\msys64\\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\\ffbuild" 2>/dev/null || echo "Path not accessible from MSYS2 shell"
          # Convert MSYS2 path to Windows path
          echo "Content of ${PREFIX}:"
          ls -la ${PREFIX}/ || echo "Not found"
          
      - name: Verify FFmpeg build output
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        shell: msys2 {0}
        run: |
          # Check MSYS2 path
          MSYS_PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          echo "Checking MSYS2 path: ${MSYS_PREFIX}"
          if [ -d "${MSYS_PREFIX}" ]; then
            echo "âœ“ MSYS2 directory exists"
            echo "Libraries: $(find ${MSYS_PREFIX}/lib -name "*.a" 2>/dev/null | wc -l)"
            echo "Headers: $(find ${MSYS_PREFIX}/include -name "*.h" 2>/dev/null | wc -l)"
            
            # Now check if it's accessible from Windows path
            WIN_PREFIX="C:/msys64/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
            echo "Checking Windows path: ${WIN_PREFIX}"
            if [ -d "${WIN_PREFIX}" ]; then
              echo "âœ“ Windows path also accessible"
            else
              echo "âœ— Windows path not accessible from MSYS2"
            fi
          else
            echo "âœ— MSYS2 directory does not exist!"
            echo "Checking if build actually created files:"
            ls -la "/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/" | head -20
          fi
      
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: |
            C:\msys64\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\ffbuild
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          
      - name: Install Node dependencies
        shell: bash
        run: |
          npm ci --ignore-scripts
          # Install node-gyp globally to avoid modifying package-lock.json
          npm install -g node-gyp

      - name: Build Native Addon
        shell: msys2 {0}
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set environment for MSYS2/Clang build
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export CC="/clang64/bin/clang"
            export CXX="/clang64/bin/clang++"
            export AR="/clang64/bin/llvm-ar"
            export LINK="/clang64/bin/clang++"
            export LD="/clang64/bin/clang++"
            STRIP_BIN="/clang64/bin/strip.exe"
            PREFIX="/clang64/ffbuild"
          else
            export CC="/clangarm64/bin/clang"
            export CXX="/clangarm64/bin/clang++"
            export AR="/clangarm64/bin/llvm-ar"
            export LINK="/clangarm64/bin/clang++"
            export LD="/clangarm64/bin/clang++"
            STRIP_BIN="/clangarm64/bin/strip.exe"
            PREFIX="/clangarm64/ffbuild"
          fi
          
          # Set pkg-config path
          export PKG_CONFIG_PATH="${PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}"
          
          # CRITICAL: Force node-gyp to use make generator instead of MSVS
          # This is essential for MSYS2/Clang builds
          export npm_config_node_gyp="$(which node-gyp)"
          export npm_config_disturl="https://nodejs.org/dist"
          export npm_config_build_from_source="true"
          
          # Set include and lib paths
          export CFLAGS="-I${PREFIX}/include"
          export CXXFLAGS="-I${PREFIX}/include"
          export LDFLAGS="-L${PREFIX}/lib"
          
          # Build N-API binary - use node-gyp directly with make generator
          # prebuildify doesn't pass the generator flag, so we need to do it manually
          NODE_VERSION="24.0.0"
          TARGET_DIR="prebuilds/win32-${{ matrix.os.arch }}"
          mkdir -p "${TARGET_DIR}"
          
          # Run node-gyp directly with make generator
          node-gyp rebuild \
            --target=${NODE_VERSION} \
            --arch=${{ matrix.os.arch }} \
            --dist-url=https://nodejs.org/dist \
            --module_name=node-av \
            --module_path="${TARGET_DIR}" \
            --napi_version=9 \
            --node_abi_napi=napi \
            --release \
            --jobs=max \
            --verbose \
            -- -f make
          
          # Move the built binary to the expected location
          if [ -f "build/Release/node-av.node" ]; then
            cp "build/Release/node-av.node" "${TARGET_DIR}/node.napi.node"
            "${STRIP_BIN}" "${TARGET_DIR}/node.napi.node"
            echo "Binary built and stripped successfully"
          else
            echo "Error: Binary not found at build/Release/node-av.node"
            ls -la build/ || true
            exit 1
          fi
          
          echo "Native addon built successfully"
          echo "Prebuild structure:"
          ls -laR prebuilds/
          
          # Copy binary for tests - check multiple possible names
          mkdir -p binary
          if [ -f "prebuilds/win32-${{ matrix.os.arch }}/node.napi.node" ]; then
            cp "prebuilds/win32-${{ matrix.os.arch }}/node.napi.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node.napi.node)"
          elif [ -f "prebuilds/win32-${{ matrix.os.arch }}/node-av.node" ]; then
            cp "prebuilds/win32-${{ matrix.os.arch }}/node-av.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node-av.node)"
          else
            echo "Warning: Binary not found at expected location"
            echo "Contents of prebuilds directory:"
            find prebuilds -name "*.node" -type f
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-windows-${{ matrix.os.arch }}
          path: prebuilds/

  # Linux builds using Docker
  build_linux:
    name: 'Linux ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: amd64
            runner: ubuntu-latest
          - arch: arm64
            target: arm64
            runner: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'
      
      - name: Prepare directories
        run: |
          # Create the prefix directory with proper permissions
          # This is needed for both cache restore and build
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:$USER /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-
            
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib} found" || echo "âœ— ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Use Jellyfin's build scripts with modification to preserve ffbuild/prefix
          # Determine target
          if [ "${{ matrix.target }}" = "amd64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi
          
          # Use our own Docker image, NOT Jellyfin's (they are private)
          cd builder
          IMAGE="ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest"
          
          # Try to pull our image from registry first
          if docker pull "${IMAGE}" 2>/dev/null; then
            echo "âœ“ Using our Docker image from registry: ${IMAGE}"
          else
            # If not available, build it locally using Jellyfin's makeimage.sh
            echo "Docker image not in registry, building locally..."
            # Set GITHUB_REPOSITORY so makeimage.sh uses our namespace
            export GITHUB_REPOSITORY="${{ github.repository }}"
            ./makeimage.sh "${TARGET}" gpl
            echo "Docker image built locally: ${IMAGE}"
          fi
          
          # Create a modified version of build.sh that preserves ffbuild/prefix
          # We copy build.sh and modify it
          cp build.sh build-preserve.sh
          # Comment out line 104 which deletes ffbuild
          sed -i '104s/^/# /' build-preserve.sh
          chmod +x build-preserve.sh
          
          # For Linux builds, add --enable-pic to ensure position-independent code
          # This fixes linking issues with shared libraries on ARM64 and x64
          if [[ "${TARGET}" == linux* ]]; then
            echo "Adding --enable-pic for Linux build..."
            sed -i 's/--enable-lto=auto/--enable-lto=auto --enable-pic/' variants/defaults-gpl.sh
            
            # For ARM64, we need to ensure NEON assembly is also PIC
            # Add explicit PIC flags to the build environment
            if [[ "${TARGET}" == *arm64* ]]; then
              echo "Adding extra PIC flags for ARM64 NEON assembly..."
              sed -i 's/FF_CFLAGS=""/FF_CFLAGS="-fPIC -DPIC"/' variants/defaults-gpl.sh
              sed -i 's/FF_CXXFLAGS=""/FF_CXXFLAGS="-fPIC -DPIC"/' variants/defaults-gpl.sh
            fi
          fi
          
          # Build FFmpeg using modified script
          echo "Building FFmpeg using modified build script..."
          # Set GITHUB_REPOSITORY so build.sh uses our Docker images
          export GITHUB_REPOSITORY="${{ github.repository }}"
          ./build-preserve.sh "${TARGET}" gpl
          
          # Now extract the prefix directory which contains all headers and static libraries
          if [ -d ffbuild/prefix ]; then
            echo "Extracting FFmpeg build artifacts..."
            sudo mkdir -p /opt/ffbuild/prefix
            sudo cp -r ffbuild/prefix/* /opt/ffbuild/prefix/
            
            # Also check if codec libraries are in /opt/ffbuild inside container
            # We might need to extract them from our Docker image
            CONTAINER_ID=$(docker create "ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest")
            # Try to copy codec libraries if they exist
            docker cp "${CONTAINER_ID}:/opt/ffbuild/lib" /tmp/codec-libs 2>/dev/null && {
              echo "Found codec libraries in Docker image, copying..."
              sudo cp -n /tmp/codec-libs/*.a /opt/ffbuild/prefix/lib/ 2>/dev/null || true
              rm -rf /tmp/codec-libs
            }
            docker cp "${CONTAINER_ID}:/opt/ffbuild/include" /tmp/codec-includes 2>/dev/null && {
              echo "Found codec headers in Docker image, copying..."
              sudo cp -rn /tmp/codec-includes/* /opt/ffbuild/prefix/include/ 2>/dev/null || true
              rm -rf /tmp/codec-includes
            }
            docker rm "${CONTAINER_ID}"
            
            # Clean up the preserved ffbuild directory now
            rm -rf ffbuild
            
            sudo chown -R $USER:$USER /opt/ffbuild
          else
            echo "Error: ffbuild/prefix not found!"
            echo "Checking what exists:"
            ls -la ffbuild/ 2>/dev/null || echo "ffbuild directory not found"
            ls -la . || echo "Current directory contents"
            exit 1
          fi
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total static libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Total headers: $(find /opt/ffbuild/prefix/include -name '*.h' | wc -l)"
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libvorbis libmp3lame; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          cd ../..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Install Node dependencies
        run: |
          # Use npm install instead of npm ci to avoid issues with optionalDependencies in Node 24
          npm install --ignore-scripts
          # Install prebuildify globally to avoid modifying package-lock.json
          npm install -g prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set up environment variables that node-gyp will use
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          
          # Use Clang to match the Docker build environment
          export CC=clang-18
          export CXX=clang++-18
          export AR=llvm-ar-18
          export NM=llvm-nm-18
          export RANLIB=llvm-ranlib-18
          export LD=ld.lld-18
          
          # Set up LTO plugin path for the linker
          LTO_PLUGIN=$(find /usr/lib -name "LLVMgold.so" 2>/dev/null | head -n1)
          if [ -z "$LTO_PLUGIN" ]; then
            LTO_PLUGIN="/usr/lib/llvm-18/lib/LLVMgold.so"
          fi
          export LDFLAGS="-fuse-ld=lld-18 -Wl,-plugin,$LTO_PLUGIN"
          
          # node-gyp reads these npm_config_* environment variables
          export npm_config_build_from_source=true
          export npm_config_jobs=max
          
          # Create a temporary .npmrc to ensure the flags are passed to node-gyp
          echo "build_from_source=true" > .npmrc
          echo "jobs=max" >> .npmrc
          
          # Build N-API binary with proper include paths
          CFLAGS="-I/opt/ffbuild/prefix/include -fPIC" \
          CXXFLAGS="-I/opt/ffbuild/prefix/include -fPIC" \
          LDFLAGS="-L/opt/ffbuild/prefix/lib -fuse-ld=lld-18 -Wl,-plugin,$LTO_PLUGIN -Wl,--allow-multiple-definition" \
          prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }} \
            --tag-libc
          
          echo "Native addon built successfully"
          echo "Checking prebuild structure:"
          ls -la prebuilds/
          ls -la prebuilds/linux-${{ matrix.arch }}/ || echo "Directory structure different"
          
          # Copy binary for tests - prebuildify creates node.napi.node or node.napi.musl.node/node.napi.glibc.node
          mkdir -p binary
          if [ -f "prebuilds/linux-${{ matrix.arch }}/node.napi.glibc.node" ]; then
            cp "prebuilds/linux-${{ matrix.arch }}/node.napi.glibc.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node.napi.glibc.node)"
          elif [ -f "prebuilds/linux-${{ matrix.arch }}/node.napi.musl.node" ]; then
            cp "prebuilds/linux-${{ matrix.arch }}/node.napi.musl.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node.napi.musl.node)"
          elif [ -f "prebuilds/linux-${{ matrix.arch }}/node.napi.node" ]; then
            cp "prebuilds/linux-${{ matrix.arch }}/node.napi.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node.napi.node)"
          elif [ -f "prebuilds/linux-${{ matrix.arch }}/node-av.node" ]; then
            cp "prebuilds/linux-${{ matrix.arch }}/node-av.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (node-av.node)"
          else
            echo "Warning: Binary not found at expected location"
            echo "Contents of prebuilds directory:"
            find prebuilds -name "*.node" -type f
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-linux-${{ matrix.arch }}
          path: prebuilds/

  # macOS builds
  build_macos:
    name: 'macOS ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            runner: macos-13  # Intel-based runner for native x64 builds
          - arch: arm64
            runner: macos-14  # Apple Silicon runner for native arm64 builds
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install build dependencies
        run: |
          # Install the same dependencies that Jellyfin's 00-dep.sh installs
          # This ensures they're in PATH for all subsequent steps
          # Check each package and only install if not already present
          PACKAGES="wget subversion mercurial autoconf automake cmake meson ninja pkg-config coreutils gcc make python-setuptools pcre2 libtool gnu-sed gnu-tar nasm quilt texinfo"
          
          for pkg in $PACKAGES; do
            if brew ls --versions "$pkg" > /dev/null 2>&1; then
              echo "$pkg is already installed, skipping..."
            else
              echo "Installing $pkg..."
              brew install "$pkg"
            fi
          done

      - name: Prepare prefix dir
        run: |
          # Always create the directory structure with proper permissions
          # This is needed for both cache restore and fresh builds
          sudo mkdir -p /opt/ffbuild/prefix
          # On macOS, use staff group instead of user's name
          sudo chown -R $USER:staff /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild
          
      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-
          
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          # Fix permissions after cache restore if needed
          sudo chown -R $USER:staff /opt/ffbuild 2>/dev/null || true
          
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib} found" || echo "âœ— ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg/builder
          
          # Map our arch names to Jellyfin's
          ARCH_NAME="${{ matrix.arch }}"
          if [ "$ARCH_NAME" = "x64" ]; then
            ARCH_NAME="x86_64"
          fi
          
          # Set deployment target to ensure proper platform load commands in libraries
          export MACOSX_DEPLOYMENT_TARGET="14.0"
          
          # Run the build script
          # Dependencies are already installed via brew in earlier step
          ./buildmac.sh $ARCH_NAME
          
          # The build script uses /ffbuild/prefix but we need /opt/ffbuild/prefix
          # Also need to run make install to get FFmpeg libraries
          cd ..
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Checking for key libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "âœ“ ${lib}" || echo "âœ— ${lib} missing"
          done
          
          # Fix permissions before caching
          sudo chown -R $USER:staff /opt/ffbuild
          
          cd ..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Install Node dependencies
        run: |
          npm ci --ignore-scripts
          # Install prebuildify globally to avoid modifying package-lock.json
          npm install -g prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Set deployment target to match Metal libraries
          export MACOSX_DEPLOYMENT_TARGET="14.0"
          
          # Build N-API binary
          prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }}
          
          echo "Native addon built successfully"
          echo "Checking prebuild structure:"
          ls -la prebuilds/
          ls -la prebuilds/darwin-${{ matrix.arch }}/ || echo "Directory structure different"
          
          # Copy binary for tests - prebuildify might create different names
          mkdir -p binary
          if [ -f "prebuilds/darwin-${{ matrix.arch }}/node.napi.node" ]; then
            cp "prebuilds/darwin-${{ matrix.arch }}/node.napi.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node (napi)"
          elif [ -f "prebuilds/darwin-${{ matrix.arch }}/node-av.node" ]; then
            cp "prebuilds/darwin-${{ matrix.arch }}/node-av.node" binary/node-av.node
            echo "Binary copied to binary/node-av.node"
          else
            echo "Warning: Binary not found at expected location"
            find prebuilds -name "*.node" -type f
            # Try to copy whatever we find
            BINARY=$(find prebuilds -name "*.node" -type f | head -1)
            if [ -n "$BINARY" ]; then
              cp "$BINARY" binary/node-av.node
              echo "Copied $BINARY to binary/node-av.node"
            fi
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-macos-${{ matrix.arch }}
          path: prebuilds/

  # Package and publish job - only runs when workflow is called from publish workflow
  package:
    name: 'Package and Publish'
    needs: [build_windows, build_linux, build_macos]
    runs-on: ubuntu-latest
    # Only run if all builds succeeded AND this is a workflow_call from publish
    if: success() && github.event_name == 'workflow_call'
    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-node@v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: |
          npm ci --ignore-scripts

      - name: Download all prebuilds
        uses: actions/download-artifact@v4
        with:
          pattern: prebuild-*
          path: prebuilds-artifacts

      - name: Prepare prebuilds structure
        run: |
          mkdir -p prebuilds
          
          # Copy all prebuilds to a single directory structure
          for dir in prebuilds-artifacts/*/; do
            cp -r "$dir"* prebuilds/
          done
          
          echo "Combined prebuilds structure:"
          ls -laR prebuilds/
          
          # Verify we have all expected platforms
          echo "\nVerifying platform coverage:"
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              echo "âœ“ $platform"
            else
              echo "âœ— $platform missing"
              exit 1  # Fail if any platform is missing
            fi
          done

      - name: Create platform packages
        run: |
          # Use the create-platform-packages.js script
          node scripts/create-platform-packages.js
          
          # Copy prebuilds to platform packages
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              # Copy the binary to the package directory
              cp "prebuilds/$platform/node-av.node" "packages/$platform/node-av.node"
              echo "Copied binary for $platform"
            fi
          done
          
          echo "Platform packages created:"
          ls -la packages/
          for pkg in packages/*/; do
            echo "Contents of $pkg:"
            ls -la "$pkg"
          done

      - name: Update version
        run: |
          # Extract version from tag
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "Version: $VERSION"
          
          # Update main package version
          npm version $VERSION --no-git-tag-version
          
          # Update platform package versions
          for pkg in packages/*/package.json; do
            if [ -f "$pkg" ]; then
              cd $(dirname "$pkg")
              npm version $VERSION --no-git-tag-version
              cd -
            fi
          done

      - name: Create release archives
        run: |
          # Create archives for each platform
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              zip -r "node-av-${platform}-${GITHUB_REF#refs/tags/}.zip" "prebuilds/$platform"
            fi
          done
          
          echo "Release archives created:"
          ls -la *.zip

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: '*.zip'
          body: |
            ## node-av Release ${{ github.ref_name }}
            
            ### ðŸ“¦ Updated Packages
            
            The following platform packages have been updated to ${{ github.ref_name }}:
            - `@seydx/node-av-darwin-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-darwin-x64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-x64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-x64@${{ github.ref_name }}`
            
            ### Installation
            ```bash
            npm install node-av@${{ github.ref_name }}
            ```

      - name: Publish to NPM
        run: |
          # Publish main package
          npm publish --access public
          
          # Publish platform packages
          for pkg_dir in packages/*/; do
            if [ -d "$pkg_dir" ]; then
              cd "$pkg_dir"
              npm publish --access public
              cd -
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}