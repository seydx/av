name: '🏗️ Build Prebuilds'

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  # Cache versions - increment when FFmpeg build configuration changes
  CACHE_VERSION_WINDOWS: 'v8'
  CACHE_VERSION_LINUX: 'v20'  # Force rebuild with PIC flags
  CACHE_VERSION_MACOS: 'v7'

on:
  workflow_dispatch:
  workflow_call:  # Allow this workflow to be called by other workflows
    secrets:
      NPM_TOKEN:
        required: false
        description: 'NPM token for publishing packages'
  # push:
  #   branches:
  #     - main
  #   paths-ignore:
  #     - '**/*.md'
  # pull_request:
  #   paths-ignore:
  #     - '**/*.md'

jobs:
  # Windows builds using MSYS2/Clang
  build_windows:
    name: 'Windows ${{ matrix.os.arch }}'
    runs-on: ${{ matrix.os.runner }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - name: CLANG64
            arch: x64
            runner: windows-latest
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - name: CLANGARM64
            arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    steps:
      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          # Important: path-type affects how paths are handled
          path-type: inherit
          install: >-
            git
            curl
            wget
            zip
            ${{ matrix.os.toolchain }}
            quilt
            diffstat
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-make
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-cmake
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-pkg-config
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-autotools

      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        shell: bash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare prefix dir
        run: |
          # Always create the directory structure with proper permissions
          # This is needed for both cache restore and fresh builds
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/include
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/bin

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: |
            C:\ffmpeg-cache-${{ matrix.os.arch }}
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-
          
      - name: Copy cache to MSYS2 location
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        shell: msys2 {0}
        run: |
          CACHE_DIR="C:/ffmpeg-cache-${{ matrix.os.arch }}"
          MSYS_PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          
          if [ -d "${CACHE_DIR}" ]; then
            echo "✓ Cache found at ${CACHE_DIR}"
            echo "Libraries in cache: $(find ${CACHE_DIR}/lib -name "*.a" 2>/dev/null | wc -l)"
            
            # Copy from cache location back to MSYS2 location
            echo "Copying to MSYS2 location: ${MSYS_PREFIX}"
            rm -rf "${MSYS_PREFIX}" 2>/dev/null || true
            mkdir -p "${MSYS_PREFIX}"
            cp -r "${CACHE_DIR}"/* "${MSYS_PREFIX}/"
            
            echo "✓ Files copied to ${MSYS_PREFIX}"
            echo "Libraries: $(ls ${MSYS_PREFIX}/lib/*.a 2>/dev/null | wc -l)"
            echo "Headers: $(ls -d ${MSYS_PREFIX}/include/*/ 2>/dev/null | wc -l)"
            
            # Quick check for key libraries
            for lib in libx264 libavcodec; do
              ls ${MSYS_PREFIX}/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
            done
          else
            echo "✗ Cache directory ${CACHE_DIR} not found!"
            exit 1
          fi

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Check if PKGBUILD directory exists, if not use builder
          if [ ! -d "PKGBUILD" ]; then
            echo "PKGBUILD directory not found, using builder directory"
            cd builder
          fi
          
          # Run Jellyfin build script (builds all dependencies + FFmpeg)
          echo "Running build script from $(pwd)"
          
          # For ARM64, we need to ensure the libraries are accessible
          if [ "${{ matrix.os.arch }}" = "arm64" ]; then
            # Build normally first
            if [ -f "../msys2/buildarm64.sh" ]; then
              ../msys2/buildarm64.sh
            elif [ -f "./buildarm64.sh" ]; then
              ./buildarm64.sh
            else
              echo "Error: buildarm64.sh not found"
              exit 1
            fi
            
            # After build, ensure libraries are in the expected location
            echo "Fixing ARM64 library paths after build..."
            if [ -d "/clangarm64/lib" ] && [ ! -d "/clangarm64/ffbuild/lib" ]; then
              echo "Copying libraries from /clangarm64/lib to /clangarm64/ffbuild/lib"
              mkdir -p /clangarm64/ffbuild/lib/pkgconfig /clangarm64/ffbuild/include
              cp -f /clangarm64/lib/*.a /clangarm64/ffbuild/lib/ 2>/dev/null || true
              cp -f /clangarm64/lib/pkgconfig/*.pc /clangarm64/ffbuild/lib/pkgconfig/ 2>/dev/null || true
              cp -rf /clangarm64/include/* /clangarm64/ffbuild/include/ 2>/dev/null || true
            fi
          else
            # For x64, run the build script normally
            if [ -f "../msys2/build.sh" ]; then
              ../msys2/build.sh
            elif [ -f "./build.sh" ]; then
              ./build.sh
            else
              echo "Error: build.sh not found"
              exit 1
            fi
          fi
          
          # After build, libraries are in /clang*/ffbuild/lib/
          # Headers are in /clang*/ffbuild/include/
          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries in ${PREFIX}/lib: $(ls ${PREFIX}/lib/*.a 2>/dev/null | wc -l)"
          echo "Key codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d libsvtav1; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          
          # Check if FFmpeg libraries are in the expected location
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          
          
          echo "=== Final library count: $(ls ${PREFIX}/lib/*.a | wc -l) ==="
          echo "=== Final header directories: $(ls -d ${PREFIX}/include/*/ | wc -l) ==="
          
          # Debug: Check what exists for cache
          echo "=== Checking cache paths ==="
          echo "MSYS2 path ${PREFIX} exists: $([ -d ${PREFIX} ] && echo 'YES' || echo 'NO')"
          echo "Windows path C:\\msys64\\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\\ffbuild exists:"
          ls -la "C:\\msys64\\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\\ffbuild" 2>/dev/null || echo "Path not accessible from MSYS2 shell"
          # Convert MSYS2 path to Windows path
          echo "Content of ${PREFIX}:"
          ls -la ${PREFIX}/ || echo "Not found"
          
      - name: Copy FFmpeg build to cache-friendly location
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        shell: msys2 {0}
        run: |
          # The cache action runs outside MSYS2 and needs a guaranteed accessible path
          # Let's copy the build artifacts to a temp location that we know works
          
          MSYS_PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          CACHE_DIR="C:/ffmpeg-cache-${{ matrix.os.arch }}"
          
          if [ -d "${MSYS_PREFIX}" ]; then
            echo "✓ FFmpeg build exists at ${MSYS_PREFIX}"
            echo "Libraries: $(find ${MSYS_PREFIX}/lib -name "*.a" 2>/dev/null | wc -l)"
            echo "Headers: $(find ${MSYS_PREFIX}/include -name "*.h" 2>/dev/null | wc -l)"
            
            # Copy to a Windows-accessible location
            echo "Copying to cache location: ${CACHE_DIR}"
            rm -rf "${CACHE_DIR}" 2>/dev/null || true
            mkdir -p "${CACHE_DIR}"
            cp -r "${MSYS_PREFIX}"/* "${CACHE_DIR}/"
            
            echo "✓ Files copied to ${CACHE_DIR}"
            echo "Libraries in cache dir: $(find ${CACHE_DIR}/lib -name "*.a" 2>/dev/null | wc -l)"
          else
            echo "✗ FFmpeg build directory does not exist!"
            exit 1
          fi
      
      - name: Verify cache path exists (Windows perspective)
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        shell: pwsh
        run: |
          Write-Host "Checking if cache path exists from Windows PowerShell perspective"
          $cachePath = "C:\ffmpeg-cache-${{ matrix.os.arch }}"
          
          if (Test-Path $cachePath) {
            Write-Host "✓ Path exists: $cachePath"
            $libCount = (Get-ChildItem -Path "$cachePath\lib" -Filter "*.a" -ErrorAction SilentlyContinue).Count
            Write-Host "✓ Found $libCount libraries in $cachePath\lib"
            
            # List some key files to verify
            Write-Host "Key libraries:"
            Get-ChildItem -Path "$cachePath\lib" -Filter "libav*.a" -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "  - $_" }
          } else {
            Write-Host "✗ Path does NOT exist: $cachePath"
          }
      
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: |
            C:\ffmpeg-cache-${{ matrix.os.arch }}
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          
      - name: Install Node dependencies
        run: |
          # Use npm install instead of npm ci to avoid issues with optionalDependencies in Node 24
          npm install --ignore-scripts
          # Install prebuildify globally to avoid modifying package-lock.json
          npm install -g prebuildify

      - name: Setup custom node-gyp
        shell: msys2 {0}
        run: |
          # Install and configure custom node-gyp from submodule
          pushd externals/node-gyp
          npm install
          npm link
          popd
          
          # Verify node-gyp is available
          which node-gyp
          node-gyp --version

      - name: Build Native Addon
        shell: msys2 {0}
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set environment for MSYS2/Clang build
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export LINK="clang++"
            export LD="clang++"
            PREFIX="/clang64/ffbuild"
          else
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export LINK="clang++"
            export LD="clang++"
            PREFIX="/clangarm64/ffbuild"
          fi
          
          # Set pkg-config path
          export PKG_CONFIG_PATH="${PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}"
          
          # Set include and lib paths
          export CFLAGS="-I${PREFIX}/include"
          export CXXFLAGS="-I${PREFIX}/include"
          export LDFLAGS="-L${PREFIX}/lib"
          
          # Force gyp to use make generator (for Python gyp code)
          export GYP_GENERATORS="make"
          
          # Use our custom node-gyp directly for better control
          # Important: Convert MSYS2 paths to Windows paths for Node.js
          NODE_GYP_PATH="$(cygpath -w $(pwd)/externals/node-gyp/bin/node-gyp.js)"
          
          # Create prebuilds directory structure
          PREBUILD_DIR="prebuilds/win32-${{ matrix.os.arch }}"
          mkdir -p "$PREBUILD_DIR"
          
          # Create MinGW import library for Node.js
          # node-gyp downloads node.lib but we need libnode.dll.a for MinGW
          NODE_VERSION=$(node --version | sed 's/v//')
          # Use the Windows user profile path, not MSYS2's HOME
          NODE_CACHE_DIR="/c/Users/runneradmin/AppData/Local/node-gyp/Cache/${NODE_VERSION}"
          
          if [ ! -f "${NODE_CACHE_DIR}/lib/libnode.dll.a" ]; then
            echo "Creating MinGW import library for Node.js..."
            mkdir -p "${NODE_CACHE_DIR}/lib"
            
            # Generate def file from node.exe (use Windows path)
            NODE_EXE_WIN="$(cygpath -w "$(which node)")"
            echo "Using Node.exe: ${NODE_EXE_WIN}"
            
            # Create def file
            gendef "${NODE_EXE_WIN}" -o "${NODE_CACHE_DIR}/lib/node.def"
            
            # Create import library from def file
            dlltool -d "${NODE_CACHE_DIR}/lib/node.def" -l "${NODE_CACHE_DIR}/lib/libnode.dll.a" -D node.exe
            
            echo "Created libnode.dll.a in ${NODE_CACHE_DIR}/lib/"
            ls -la "${NODE_CACHE_DIR}/lib/"
          else
            echo "libnode.dll.a already exists"
          fi
          
          # Build with node-gyp directly using make format
          node "${NODE_GYP_PATH}" rebuild \
            --verbose \
            -f make \
            --arch=${{ matrix.os.arch }} \
            --release
          
          # Copy the built binary to prebuilds
          cp build/Release/node-av.node "$PREBUILD_DIR/node.napi.node"
          
          # Strip the binary if needed
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            llvm-strip "$PREBUILD_DIR/node.napi.node"
          else
            llvm-strip "$PREBUILD_DIR/node.napi.node"
          fi
          
          echo "Native addon built successfully"
          echo "Prebuild structure:"
          ls -laR prebuilds/
          
          # Copy binary for tests - find and copy the first .node file
          mkdir -p binary
          
          # List contents for debugging
          echo "Contents of prebuilds directory:"
          ls -la prebuilds/*/ || true
          
          # Find and copy the first .node file
          NODE_FILE=$(find prebuilds -name "*.node" -type f | head -1)
          
          if [ -n "$NODE_FILE" ]; then
            cp "$NODE_FILE" binary/node-av.node
            echo "Copied $NODE_FILE to binary/node-av.node"
          else
            echo "Error: No .node file found in prebuilds directory"
            exit 1
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-windows-${{ matrix.os.arch }}
          path: prebuilds/

  # Linux builds using Docker
  build_linux:
    name: 'Linux ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: amd64
            runner: ubuntu-latest
          - arch: arm64
            target: arm64
            runner: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'
      
      - name: Prepare directories
        run: |
          # Create the prefix directory with proper permissions
          # This is needed for both cache restore and build
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:$USER /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-
            
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Use Jellyfin's build scripts with modification to preserve ffbuild/prefix
          # Determine target
          if [ "${{ matrix.target }}" = "amd64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi
          
          # Use our own Docker image, NOT Jellyfin's (they are private)
          cd builder
          IMAGE="ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest"
          
          # Try to pull our image from registry first
          if docker pull "${IMAGE}" 2>/dev/null; then
            echo "✓ Using our Docker image from registry: ${IMAGE}"
          else
            # If not available, build it locally using Jellyfin's makeimage.sh
            echo "Docker image not in registry, building locally..."
            # Set GITHUB_REPOSITORY so makeimage.sh uses our namespace
            export GITHUB_REPOSITORY="${{ github.repository }}"
            ./makeimage.sh "${TARGET}" gpl
            echo "Docker image built locally: ${IMAGE}"
          fi
          
          # Create a modified version of build.sh that preserves ffbuild/prefix
          # We copy build.sh and modify it
          cp build.sh build-preserve.sh
          # Comment out line 104 which deletes ffbuild
          sed -i '104s/^/# /' build-preserve.sh
          chmod +x build-preserve.sh
          
          # For Linux builds, add --enable-pic to ensure position-independent code
          # This fixes linking issues with shared libraries on ARM64 and x64
          if [[ "${TARGET}" == linux* ]]; then
            echo "Configuring Linux build with PIC support..."
            
            # First backup the original
            cp variants/defaults-gpl.sh variants/defaults-gpl.sh.orig
            
            # Modify configure flags based on architecture
            if [[ "${TARGET}" == *arm64* ]]; then
              echo "Configuring for ARM64 without LTO..."
              # Remove LTO and add PIC for ARM64
              sed -i '/--enable-lto=auto/d' variants/defaults-gpl.sh
              # Add --enable-pic to the end of configure line
              sed -i '/^FF_CONFIGURE=/s/"$/ --enable-pic"/' variants/defaults-gpl.sh
            else
              echo "Configuring for x64 with LTO and PIC..."
              # Replace LTO line to include PIC for x64
              sed -i 's/--enable-lto=auto/--enable-lto=auto --enable-pic/' variants/defaults-gpl.sh
            fi
            
            # Force PIC flags in all compilation
            # Append to the file to ensure these override any defaults
            echo '' >> variants/defaults-gpl.sh
            echo '# Force PIC for shared library compatibility' >> variants/defaults-gpl.sh
            echo 'FF_CFLAGS="${FF_CFLAGS} -fPIC -DPIC"' >> variants/defaults-gpl.sh
            echo 'FF_CXXFLAGS="${FF_CXXFLAGS} -fPIC -DPIC"' >> variants/defaults-gpl.sh
            echo 'FF_LDFLAGS="${FF_LDFLAGS} -fPIC"' >> variants/defaults-gpl.sh
            
            # IMPORTANT: For both x64 and ARM64, we need assembly PIC support
            # x86_64 uses YASM/NASM which needs -DPIC
            # ARM64 uses GAS which also needs -DPIC
            echo 'FF_ASFLAGS="${FF_ASFLAGS} -DPIC"' >> variants/defaults-gpl.sh
            echo 'export FF_CFLAGS FF_CXXFLAGS FF_LDFLAGS FF_ASFLAGS' >> variants/defaults-gpl.sh
            
            # Display the final configuration for debugging
            echo "Final configuration:"
            cat variants/defaults-gpl.sh
          fi
          
          # Build FFmpeg using modified script
          echo "Building FFmpeg using modified build script..."
          # Set GITHUB_REPOSITORY so build.sh uses our Docker images
          export GITHUB_REPOSITORY="${{ github.repository }}"
          ./build-preserve.sh "${TARGET}" gpl
          
          # Now extract the prefix directory which contains all headers and static libraries
          if [ -d ffbuild/prefix ]; then
            echo "Extracting FFmpeg build artifacts..."
            sudo mkdir -p /opt/ffbuild/prefix
            sudo cp -r ffbuild/prefix/* /opt/ffbuild/prefix/
            
            # Also check if codec libraries are in /opt/ffbuild inside container
            # We might need to extract them from our Docker image
            CONTAINER_ID=$(docker create "ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest")
            # Try to copy codec libraries if they exist
            docker cp "${CONTAINER_ID}:/opt/ffbuild/lib" /tmp/codec-libs 2>/dev/null && {
              echo "Found codec libraries in Docker image, copying..."
              sudo cp -n /tmp/codec-libs/*.a /opt/ffbuild/prefix/lib/ 2>/dev/null || true
              rm -rf /tmp/codec-libs
            }
            docker cp "${CONTAINER_ID}:/opt/ffbuild/include" /tmp/codec-includes 2>/dev/null && {
              echo "Found codec headers in Docker image, copying..."
              sudo cp -rn /tmp/codec-includes/* /opt/ffbuild/prefix/include/ 2>/dev/null || true
              rm -rf /tmp/codec-includes
            }
            docker rm "${CONTAINER_ID}"
            
            # Clean up the preserved ffbuild directory now
            rm -rf ffbuild
            
            sudo chown -R $USER:$USER /opt/ffbuild
          else
            echo "Error: ffbuild/prefix not found!"
            echo "Checking what exists:"
            ls -la ffbuild/ 2>/dev/null || echo "ffbuild directory not found"
            ls -la . || echo "Current directory contents"
            exit 1
          fi
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total static libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Total headers: $(find /opt/ffbuild/prefix/include -name '*.h' | wc -l)"
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libvorbis libmp3lame; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          cd ../..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Install Node dependencies
        run: |
          # Use npm install instead of npm ci to avoid issues with optionalDependencies in Node 24
          npm install --ignore-scripts
          # Install prebuildify globally to avoid modifying package-lock.json
          npm install -g prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set up environment variables that node-gyp will use
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          
          # Use Clang to match the Docker build environment
          export CC=clang-18
          export CXX=clang++-18
          export AR=llvm-ar-18
          export NM=llvm-nm-18
          export RANLIB=llvm-ranlib-18
          
          # For ARM64, use lld without LTO plugin (since we disabled LTO for ARM64)
          # For x64, use lld with LTO plugin
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            # Use lld for ARM64 with text relocations allowed for NEON assembly
            export LD=ld.lld-18
            # No LTO plugin needed since we disabled LTO for ARM64
            export LDFLAGS="-fuse-ld=lld-18 -Wl,-z,notext"
            BUILD_LDFLAGS="-L/opt/ffbuild/prefix/lib -fuse-ld=lld-18 -Wl,--allow-multiple-definition -Wl,-z,notext"
          else
            # For x64, use lld with LTO
            export LD=ld.lld-18
            LTO_PLUGIN=$(find /usr/lib -name "LLVMgold.so" 2>/dev/null | head -n1)
            if [ -z "$LTO_PLUGIN" ]; then
              LTO_PLUGIN="/usr/lib/llvm-18/lib/LLVMgold.so"
            fi
            export LDFLAGS="-fuse-ld=lld-18 -Wl,-plugin,$LTO_PLUGIN"
            BUILD_LDFLAGS="-L/opt/ffbuild/prefix/lib -fuse-ld=lld-18 -Wl,-plugin,$LTO_PLUGIN -Wl,--allow-multiple-definition"
          fi
          
          # Build N-API binary with proper include paths
          CFLAGS="-I/opt/ffbuild/prefix/include -fPIC" \
          CXXFLAGS="-I/opt/ffbuild/prefix/include -fPIC" \
          LDFLAGS="$BUILD_LDFLAGS" \
          prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }} \
            --tag-libc
          
          echo "Native addon built successfully"
          echo "Checking prebuild structure:"
          ls -la prebuilds/
          ls -la prebuilds/linux-${{ matrix.arch }}/ || echo "Directory structure different"
          
          # Copy binary for tests - find and copy the first .node file
          mkdir -p binary
          
          # List contents for debugging
          echo "Contents of prebuilds directory:"
          ls -la prebuilds/*/ || true
          
          # Find and copy the first .node file
          NODE_FILE=$(find prebuilds -name "*.node" -type f | head -1)
          
          if [ -n "$NODE_FILE" ]; then
            cp "$NODE_FILE" binary/node-av.node
            echo "Copied $NODE_FILE to binary/node-av.node"
          else
            echo "Error: No .node file found in prebuilds directory"
            exit 1
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-linux-${{ matrix.arch }}
          path: prebuilds/

  # macOS builds
  build_macos:
    name: 'macOS ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            runner: macos-13  # Intel-based runner for native x64 builds
          - arch: arm64
            runner: macos-14  # Apple Silicon runner for native arm64 builds
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Install build dependencies
        run: |
          # Install the same dependencies that Jellyfin's 00-dep.sh installs
          # This ensures they're in PATH for all subsequent steps
          # Check each package and only install if not already present
          PACKAGES="wget subversion mercurial autoconf automake cmake meson ninja pkg-config coreutils gcc make python-setuptools pcre2 libtool gnu-sed gnu-tar nasm quilt texinfo"
          
          for pkg in $PACKAGES; do
            if brew ls --versions "$pkg" > /dev/null 2>&1; then
              echo "$pkg is already installed, skipping..."
            else
              echo "Installing $pkg..."
              brew install "$pkg"
            fi
          done

      - name: Prepare prefix dir
        run: |
          # Always create the directory structure with proper permissions
          # This is needed for both cache restore and fresh builds
          sudo mkdir -p /opt/ffbuild/prefix
          # On macOS, use staff group instead of user's name
          sudo chown -R $USER:staff /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild
          
      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-
          
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          # Fix permissions after cache restore if needed
          sudo chown -R $USER:staff /opt/ffbuild 2>/dev/null || true
          
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg/builder
          
          # Map our arch names to Jellyfin's
          ARCH_NAME="${{ matrix.arch }}"
          if [ "$ARCH_NAME" = "x64" ]; then
            ARCH_NAME="x86_64"
          fi
          
          # Set deployment target to ensure proper platform load commands in libraries
          export MACOSX_DEPLOYMENT_TARGET="14.0"
          
          # Run the build script
          # Dependencies are already installed via brew in earlier step
          ./buildmac.sh $ARCH_NAME
          
          # The build script uses /ffbuild/prefix but we need /opt/ffbuild/prefix
          # Also need to run make install to get FFmpeg libraries
          cd ..
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Checking for key libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          
          # Fix permissions before caching
          sudo chown -R $USER:staff /opt/ffbuild
          
          cd ..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Install Node dependencies
        run: |
          # Use npm install instead of npm ci to avoid issues with optionalDependencies in Node 24
          npm install --ignore-scripts
          # Install prebuildify globally to avoid modifying package-lock.json
          npm install -g prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Set deployment target to match Metal libraries
          export MACOSX_DEPLOYMENT_TARGET="14.0"
          
          # Build N-API binary
          prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }}
          
          echo "Native addon built successfully"
          echo "Checking prebuild structure:"
          ls -la prebuilds/
          ls -la prebuilds/darwin-${{ matrix.arch }}/ || echo "Directory structure different"
          
          # Copy binary for tests - find and copy the first .node file
          mkdir -p binary
          
          # List contents for debugging
          echo "Contents of prebuilds directory:"
          ls -la prebuilds/*/ || true
          
          # Find and copy the first .node file
          NODE_FILE=$(find prebuilds -name "*.node" -type f | head -1)
          
          if [ -n "$NODE_FILE" ]; then
            cp "$NODE_FILE" binary/node-av.node
            echo "Copied $NODE_FILE to binary/node-av.node"
          else
            echo "Error: No .node file found in prebuilds directory"
            exit 1
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-macos-${{ matrix.arch }}
          path: prebuilds/

  # Package and publish job - only runs when workflow is called from publish workflow
  package:
    name: 'Package and Publish'
    needs: [build_windows, build_linux, build_macos]
    runs-on: ubuntu-latest
    # Only run if all builds succeeded AND this is a workflow_call from publish
    if: success() && github.event_name == 'workflow_call'
    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-node@v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: |
          # Use npm install instead of npm ci to avoid issues with optionalDependencies in Node 24
          npm install --ignore-scripts

      - name: Download all prebuilds
        uses: actions/download-artifact@v4
        with:
          pattern: prebuild-*
          path: prebuilds-artifacts

      - name: Prepare prebuilds structure
        run: |
          mkdir -p prebuilds
          
          # Copy all prebuilds to a single directory structure
          for dir in prebuilds-artifacts/*/; do
            cp -r "$dir"* prebuilds/
          done
          
          echo "Combined prebuilds structure:"
          ls -laR prebuilds/
          
          # Verify we have all expected platforms
          echo "\nVerifying platform coverage:"
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              echo "✓ $platform"
            else
              echo "✗ $platform missing"
              exit 1  # Fail if any platform is missing
            fi
          done

      - name: Create platform packages
        run: |
          # Use the create-platform-packages.js script
          node scripts/create-platform-packages.js
          
          # Copy prebuilds to platform packages
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              # Copy the binary to the package directory
              cp "prebuilds/$platform/node-av.node" "packages/$platform/node-av.node"
              echo "Copied binary for $platform"
            fi
          done
          
          echo "Platform packages created:"
          ls -la packages/
          for pkg in packages/*/; do
            echo "Contents of $pkg:"
            ls -la "$pkg"
          done

      - name: Update version
        run: |
          # Extract version from tag
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "Version: $VERSION"
          
          # Update main package version
          npm version $VERSION --no-git-tag-version
          
          # Update platform package versions
          for pkg in packages/*/package.json; do
            if [ -f "$pkg" ]; then
              cd $(dirname "$pkg")
              npm version $VERSION --no-git-tag-version
              cd -
            fi
          done

      - name: Create release archives
        run: |
          # Create archives for each platform
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              zip -r "node-av-${platform}-${GITHUB_REF#refs/tags/}.zip" "prebuilds/$platform"
            fi
          done
          
          echo "Release archives created:"
          ls -la *.zip

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: '*.zip'
          body: |
            ## node-av Release ${{ github.ref_name }}
            
            ### 📦 Updated Packages
            
            The following platform packages have been updated to ${{ github.ref_name }}:
            - `@seydx/node-av-darwin-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-darwin-x64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-x64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-x64@${{ github.ref_name }}`
            
            ### Installation
            ```bash
            npm install node-av@${{ github.ref_name }}
            ```

      - name: Publish to NPM
        run: |
          # Publish main package
          npm publish --access public
          
          # Publish platform packages
          for pkg_dir in packages/*/; do
            if [ -d "$pkg_dir" ]; then
              cd "$pkg_dir"
              npm publish --access public
              cd -
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}