name: '🏗️ Build Prebuilds'

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

on:
  workflow_dispatch:
  workflow_call:  # Allow this workflow to be called by other workflows
    secrets:
      NPM_TOKEN:
        required: false
        description: 'NPM token for publishing packages'
  # push:
  #   branches:
  #     - main
  #   paths-ignore:
  #     - '**/*.md'
  # pull_request:
  #   paths-ignore:
  #     - '**/*.md'

jobs:
  # Windows builds using MSYS2/Clang
  build_windows:
    name: 'Windows ${{ matrix.os.arch }}'
    runs-on: ${{ matrix.os.runner }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - name: CLANG64
            arch: x64
            runner: windows-latest
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - name: CLANGARM64
            arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    steps:
      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          # Important: path-type affects how paths are handled
          path-type: inherit
          install: >-
            git
            curl
            wget
            zip
            ${{ matrix.os.toolchain }}
            quilt
            diffstat
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-make
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-cmake
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-pkg-config
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-autotools

      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: |
            C:\msys64\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\ffbuild
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v3
          restore-keys: |
            ffmpeg-windows-${{ matrix.os.arch }}-

      - name: Prepare prefix dir
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          # Create ffbuild directory if it doesn't exist
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild
          
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls ${PREFIX}/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d ${PREFIX}/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Run Jellyfin build script (builds all dependencies + FFmpeg)
          ${{ matrix.os.build_script }}
          
          # After build, libraries are in /clang*/ffbuild/lib/
          # Headers are in /clang*/ffbuild/include/
          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries in ${PREFIX}/lib: $(ls ${PREFIX}/lib/*.a 2>/dev/null | wc -l)"
          echo "Key codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d libsvtav1; do
            ls ${PREFIX}/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          
          # Also need FFmpeg's own libraries after make install
          make install
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls ${PREFIX}/jellyfin-ffmpeg/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          
          # Copy FFmpeg libraries to main lib directory for easier access
          cp ${PREFIX}/jellyfin-ffmpeg/lib/*.a ${PREFIX}/lib/ 2>/dev/null || true
          cp -r ${PREFIX}/jellyfin-ffmpeg/include/* ${PREFIX}/include/ 2>/dev/null || true
          
          # Also copy pkg-config files
          mkdir -p ${PREFIX}/lib/pkgconfig
          cp ${PREFIX}/jellyfin-ffmpeg/lib/pkgconfig/*.pc ${PREFIX}/lib/pkgconfig/ 2>/dev/null || true
          
          echo "=== Final library count: $(ls ${PREFIX}/lib/*.a | wc -l) ==="
          echo "=== Final header directories: $(ls -d ${PREFIX}/include/*/ | wc -l) ==="
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            C:\msys64\${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}\ffbuild
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v3
          
      - name: Install Node dependencies
        shell: bash
        run: |
          npm ci --ignore-scripts
          npm install --no-save prebuildify

      - name: Build Native Addon
        shell: bash
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Convert MSYS2 paths for Windows compatibility
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            sed -i 's|/clang64|C:\\\\msys64\\\\clang64|g' binding.gyp
            STRIP_BIN="C:\\msys64\\clang64\\bin\\strip.exe"
          else
            sed -i 's|/clangarm64|C:\\\\msys64\\\\clangarm64|g' binding.gyp
            STRIP_BIN="C:\\msys64\\clangarm64\\bin\\strip.exe"
          fi
          
          # Build N-API binary
          npx prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.os.arch }} \
            --strip-bin="${STRIP_BIN}"
          
          echo "Native addon built successfully"
          echo "Prebuild structure:"
          ls -laR prebuilds/
          
          # Copy binary for tests
          mkdir -p build
          if [ -f "prebuilds/win32-${{ matrix.os.arch }}/node-av.node" ]; then
            cp "prebuilds/win32-${{ matrix.os.arch }}/node-av.node" build/node-av.node
            echo "Binary copied for tests"
          else
            echo "Warning: Binary not found at expected location"
            find prebuilds -name "*.node" -type f
          fi

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-windows-${{ matrix.os.arch }}
          path: prebuilds/

  # Linux builds using Docker
  build_linux:
    name: 'Linux ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: amd64
            runner: ubuntu-latest
          - arch: arm64
            target: arm64
            runner: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
      
      - name: Prepare directories
        run: |
          # Create the prefix directory with proper permissions
          # This is needed for both cache restore and build
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chmod -R 777 /opt/ffbuild

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}
          restore-keys: |
            ffmpeg-linux-${{ matrix.arch }}-
            
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Set environment to use our repository namespace for Docker images
          # This makes Jellyfin's scripts use ghcr.io/<our-repo>/ instead of ghcr.io/jellyfin/jellyfin-ffmpeg/
          export GITHUB_REPOSITORY="${{ github.repository }}"
          
          # Build using Jellyfin's builder scripts
          cd builder
          
          # Determine target
          if [ "${{ matrix.target }}" = "amd64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi
          
          # The build.sh script will:
          # 1. Try to pull ghcr.io/<our-repo>/${TARGET}-gpl:latest
          # 2. If not found, build.sh uses the base image to build
          # Note: makeimage.sh creates the Docker image if needed
          
          # Check if our Docker image exists
          DOCKER_IMAGE="ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest"
          echo "Checking for Docker image: ${DOCKER_IMAGE}"
          
          if ! docker pull "${DOCKER_IMAGE}" 2>/dev/null; then
            echo "Docker image not found, building it locally..."
            # Build the Docker image locally (for this run only)
            # Note: We do NOT push it - that's handled by build-docker-images.yaml
            ./makeimage.sh "${TARGET}" gpl
            echo "Docker image built locally for this run"
          else
            echo "✓ Using existing Docker image from registry"
          fi
          
          # Run the build with the Docker image (now guaranteed to exist)
          # IMPORTANT: build.sh creates ffbuild/prefix/ with libraries,
          # but then deletes it at the end! We need to preserve it.
          
          # Modify build.sh to not delete ffbuild directory
          # We make a copy and patch it
          cp build.sh build-preserve.sh
          # Comment out the rm -rf ffbuild line
          sed -i 's/^rm -rf ffbuild/#rm -rf ffbuild/' build-preserve.sh
          
          # Run our modified build script
          ./build-preserve.sh "${TARGET}" gpl
          
          # Now the libraries are in ffbuild/prefix/ and won't be deleted
          # Move them to our standard location
          sudo mkdir -p /opt/ffbuild
          if [ -d "ffbuild/prefix" ]; then
            sudo mv ffbuild/prefix /opt/ffbuild/
            echo "Libraries successfully moved to /opt/ffbuild/prefix"
          else
            echo "ERROR: ffbuild/prefix not found after build!"
            ls -la ffbuild/ || echo "ffbuild directory not found"
            exit 1
          fi
          
          # Clean up
          rm -rf ffbuild build-preserve.sh
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total static libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Total headers: $(find /opt/ffbuild/prefix/include -name '*.h' | wc -l)"
          echo "FFmpeg libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d libfdk-aac; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          echo "PKG-CONFIG files:"
          ls /opt/ffbuild/prefix/lib/pkgconfig/*.pc 2>/dev/null | head -5 || echo "No .pc files found"
          cd ../..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-linux-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}

      - name: Install Node dependencies
        run: |
          npm ci --ignore-scripts
          npm install --no-save prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build N-API binary
          npx prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }} \
            --tag-libc
          
          echo "Native addon built successfully"
          ls -la prebuilds/
          
          # Copy binary for tests
          mkdir -p build
          cp prebuilds/linux-${{ matrix.arch }}/node-av.node build/node-av.node || true

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-linux-${{ matrix.arch }}
          path: prebuilds/

  # macOS builds
  build_macos:
    name: 'macOS ${{ matrix.arch }}'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            runner: macos-13  # Intel-based runner for native x64 builds
          - arch: arm64
            runner: macos-14  # Apple Silicon runner for native arm64 builds
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Prepare prefix dir
        run: |
          # Always create the directory structure with proper permissions
          # This is needed for both cache restore and fresh builds
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chmod -R 777 /opt/ffbuild
          
      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v2
          restore-keys: |
            ffmpeg-macos-${{ matrix.arch }}-
          
      - name: Verify cache restoration
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        run: |
          # Fix permissions after cache restore (cache might restore with wrong permissions)
          sudo chmod -R 755 /opt/ffbuild/prefix 2>/dev/null || true
          
          echo "Cache restored, checking contents:"
          echo "Libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Headers: $(ls -d /opt/ffbuild/prefix/include/*/ 2>/dev/null | wc -l)"
          # Quick check for key libraries
          for lib in libx264 libavcodec; do
            ls /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib} found" || echo "✗ ${lib} missing - cache may be incomplete"
          done

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg/builder
          
          # Map our arch names to Jellyfin's
          ARCH_NAME="${{ matrix.arch }}"
          if [ "$ARCH_NAME" = "x64" ]; then
            ARCH_NAME="x86_64"
          fi
          
          # Run the build script
          ./buildmac.sh $ARCH_NAME
          
          # The build script uses /ffbuild/prefix but we need /opt/ffbuild/prefix
          # Also need to run make install to get FFmpeg libraries
          cd ..
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"
          
          echo "=== Build completed, verifying outputs ==="
          echo "Total libraries: $(ls /opt/ffbuild/prefix/lib/*.a 2>/dev/null | wc -l)"
          echo "Checking for key libraries:"
          for lib in libavcodec libavformat libavutil libavfilter libswscale libswresample; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          echo "Codec libraries:"
          for lib in libx264 libx265 libopus libvpx libdav1d; do
            ls -la /opt/ffbuild/prefix/lib/${lib}.a 2>/dev/null && echo "✓ ${lib}" || echo "✗ ${lib} missing"
          done
          cd ..
          
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-macos-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v2

      - name: Install Node dependencies
        run: |
          npm ci --ignore-scripts
          npm install --no-save prebuildify

      - name: Build Native Addon
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build N-API binary
          npx prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }}
          
          echo "Native addon built successfully"
          ls -la prebuilds/
          
          # Copy binary for tests
          mkdir -p build
          cp prebuilds/darwin-${{ matrix.arch }}/node-av.node build/node-av.node || true

      - name: Run Tests
        run: |
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v4
        with:
          name: prebuild-macos-${{ matrix.arch }}
          path: prebuilds/

  # Package and publish job - only runs when workflow is called from publish workflow
  package:
    name: 'Package and Publish'
    needs: [build_windows, build_linux, build_macos]
    runs-on: ubuntu-latest
    # Only run if all builds succeeded AND this is a workflow_call from publish
    if: success() && github.event_name == 'workflow_call'
    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: |
          npm ci --ignore-scripts

      - name: Download all prebuilds
        uses: actions/download-artifact@v4
        with:
          pattern: prebuild-*
          path: prebuilds-artifacts

      - name: Prepare prebuilds structure
        run: |
          mkdir -p prebuilds
          
          # Copy all prebuilds to a single directory structure
          for dir in prebuilds-artifacts/*/; do
            cp -r "$dir"* prebuilds/
          done
          
          echo "Combined prebuilds structure:"
          ls -laR prebuilds/
          
          # Verify we have all expected platforms
          echo "\nVerifying platform coverage:"
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              echo "✓ $platform"
            else
              echo "✗ $platform missing"
              exit 1  # Fail if any platform is missing
            fi
          done

      - name: Create platform packages
        run: |
          # Use the create-platform-packages.js script
          node scripts/create-platform-packages.js
          
          # Copy prebuilds to platform packages
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              # Copy the binary to the package directory
              cp "prebuilds/$platform/node-av.node" "packages/$platform/node-av.node"
              echo "Copied binary for $platform"
            fi
          done
          
          echo "Platform packages created:"
          ls -la packages/
          for pkg in packages/*/; do
            echo "Contents of $pkg:"
            ls -la "$pkg"
          done

      - name: Update version
        run: |
          # Extract version from tag
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "Version: $VERSION"
          
          # Update main package version
          npm version $VERSION --no-git-tag-version
          
          # Update platform package versions
          for pkg in packages/*/package.json; do
            if [ -f "$pkg" ]; then
              cd $(dirname "$pkg")
              npm version $VERSION --no-git-tag-version
              cd -
            fi
          done

      - name: Create release archives
        run: |
          # Create archives for each platform
          for platform in darwin-x64 darwin-arm64 linux-x64 linux-arm64 win32-x64 win32-arm64; do
            if [ -d "prebuilds/$platform" ]; then
              zip -r "node-av-${platform}-${GITHUB_REF#refs/tags/}.zip" "prebuilds/$platform"
            fi
          done
          
          echo "Release archives created:"
          ls -la *.zip

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: '*.zip'
          body: |
            ## node-av Release ${{ github.ref_name }}
            
            ### 📦 Updated Packages
            
            The following platform packages have been updated to ${{ github.ref_name }}:
            - `@seydx/node-av-darwin-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-darwin-x64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-linux-x64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-arm64@${{ github.ref_name }}`
            - `@seydx/node-av-win32-x64@${{ github.ref_name }}`
            
            ### Installation
            ```bash
            npm install node-av@${{ github.ref_name }}
            ```

      - name: Publish to NPM
        run: |
          # Publish main package
          npm publish --access public
          
          # Publish platform packages
          for pkg_dir in packages/*/; do
            if [ -d "$pkg_dir" ]; then
              cd "$pkg_dir"
              npm publish --access public
              cd -
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}