name: '🏗️ Build Prebuilds'

on:
  # push:
  #   branches: [main]
  # pull_request:
  workflow_dispatch:
  workflow_call:

jobs:
  build_mac:
    name: 'macOS ${{ matrix.arch }}'
    runs-on: macos-13
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        include:
          - arch: x64
            target: mac64
          - arch: arm64
            target: macarm64
    
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Install Dependencies
        run: |
          # Install all dependencies required by Jellyfin's buildmac.sh
          brew install wget subversion mercurial autoconf automake cmake meson ninja pkg-config coreutils gcc make python-setuptools pcre2 libtool gnu-sed gnu-tar nasm yasm quilt texinfo
          # Ensure gsed is available (gnu-sed installs it as gsed)
          which gsed || brew link --force gnu-sed
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-jellyfin-macos-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v2
          restore-keys: |
            ffmpeg-jellyfin-macos-${{ matrix.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          # Prepare prefix dir exactly like Jellyfin does
          sudo mkdir -p /opt/ffbuild
          sudo chmod 777 /opt/ffbuild
          
          # WORKAROUND: macOS GitHub runners don't allow creating symlinks in root
          # Try to create symlink, but don't fail if it doesn't work
          if sudo ln -s /opt/ffbuild /ffbuild 2>/dev/null; then
            echo "Symlink created successfully"
          else
            echo "Cannot create symlink in root (expected on GitHub runners)"
            # We'll handle this by modifying the configure prefix
          fi
          
          # Run buildmac.sh from the jellyfin-ffmpeg root
          cd externals/jellyfin-ffmpeg
          
          # If symlink failed, we need to patch the build script
          if [ ! -L /ffbuild ]; then
            echo "Patching buildmac.sh to use /opt/ffbuild instead of /ffbuild"
            # The script already sets FFBUILD_PREFIX correctly, but configure uses hardcoded path
            sed -i '' 's|--prefix=/ffbuild/prefix|--prefix=/opt/ffbuild/prefix|' builder/buildmac.sh
          fi
          
          # Map GitHub arch to Jellyfin arch
          # IMPORTANT: Set PKG_CONFIG_PATH so FFmpeg can find the dependencies
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          if [ "${{ matrix.arch }}" = "x64" ]; then
            ./builder/buildmac.sh x86_64
          else
            ./builder/buildmac.sh arm64
          fi
          
          # buildmac.sh does configure + make, but NOT make install
          echo "Installing FFmpeg libraries and headers..."
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"
          
          cd ../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
      
      - name: Build Native Binary
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build using node-gyp directly (N-API ensures compatibility)
          npx node-gyp rebuild
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        run: |
          npm run test:all
        env:
          PKG_CONFIG_PATH: "/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        run: |
          mkdir -p artifacts
          artifact_name="node-av-darwin-${{ matrix.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-darwin-${{ matrix.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip

  build_linux:
    name: 'Linux ${{ matrix.arch }}'
    runs-on: ubuntu-latest
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        include:
          - arch: x64
            target: linux64
          - arch: arm64
            target: linuxarm64
    
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: |
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-jellyfin-linux-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v4
          restore-keys: |
            ffmpeg-jellyfin-linux-${{ matrix.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Determine target architecture
          if [ "${{ matrix.arch }}" = "x64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi
          
          # Try to use pre-built Docker image from our registry
          OUR_IMAGE="ghcr.io/${{ github.repository }}/${TARGET}-gpl:latest"
          
          if docker pull "$OUR_IMAGE" 2>/dev/null; then
            echo "Using pre-built Docker image from our registry"
          else
            echo "No pre-built image found, building from scratch"
            
            # Build using Jellyfin's script which creates a Docker image locally
            cd builder
            # Set our repository instead of jellyfin's
            export GITHUB_REPOSITORY="${{ github.repository }}"
            ./makeimage.sh "$TARGET" gpl
            cd ..
          fi
          
          # Now we have the Docker image, let's build FFmpeg and extract libraries/headers
          echo "Building FFmpeg libraries and extracting from Docker..."
          
          # Use Jellyfin's build.sh approach - prepare local directories (same as in build.sh)
          cd builder
          rm -rf ffbuild
          mkdir -p ffbuild/ffmpeg
          # Copy parent directory (jellyfin-ffmpeg) to ffbuild/ffmpeg, excluding builder
          rsync -a .. ffbuild/ffmpeg --exclude=$(basename "$PWD")
          
          # Create a build script that will run inside Docker
          cat > build-ffmpeg-libs.sh << 'EOF'
          #!/bin/bash
          set -xe
          cd /ffbuild
          cd ffmpeg
          
          # Apply patches if any
          if [[ -f "debian/patches/series" ]]; then
            ln -s /ffbuild/ffmpeg/debian/patches patches
            quilt push -a
          fi
          
          # The Docker image already has all dependencies installed in /ffbuild/prefix
          # We need to preserve them while building FFmpeg
          
          # First, backup the existing libraries (dependencies)
          cp -r /ffbuild/prefix /ffbuild/prefix.backup || true
          
          # Configure FFmpeg with all the collected flags
          ./configure --prefix=/ffbuild/prefix \
            $FFBUILD_TARGET_FLAGS \
            --extra-version="Jellyfin" \
            --extra-cflags="$FF_CFLAGS" \
            --extra-cxxflags="$FF_CXXFLAGS" \
            --extra-ldflags="$FF_LDFLAGS" \
            --extra-ldexeflags="$FF_LDEXEFLAGS" \
            --extra-libs="$FF_LIBS" \
            $FF_CONFIGURE
          
          # Build FFmpeg
          make -j$(nproc)
          
          # Install FFmpeg (this adds to existing prefix)
          make install
          
          # Restore any missing dependency libraries (in case make install removed some)
          if [ -d /ffbuild/prefix.backup ]; then
            cp -n /ffbuild/prefix.backup/lib/*.a /ffbuild/prefix/lib/ 2>/dev/null || true
            cp -n /ffbuild/prefix.backup/lib/*.so* /ffbuild/prefix/lib/ 2>/dev/null || true
          fi
          
          # Package the results (all libraries and headers)
          cd /ffbuild
          tar czf /output/ffmpeg-dev.tar.gz prefix/
          EOF
          
          chmod +x build-ffmpeg-libs.sh
          
          # Run the build script in Docker (mount ffbuild directory like Jellyfin does)
          mkdir -p output
          docker run --rm -v $(pwd)/ffbuild:/ffbuild -v $(pwd)/output:/output -v $(pwd)/build-ffmpeg-libs.sh:/build.sh "$OUR_IMAGE" bash /build.sh
          
          # Extract the libraries and headers to the expected location
          sudo mkdir -p /opt/ffbuild
          sudo tar xzf output/ffmpeg-dev.tar.gz -C /opt/ffbuild/
          
          # Cleanup (use sudo because files are owned by docker user)
          sudo rm -rf ffbuild output build-ffmpeg-libs.sh
          
          # Go back to repository root (we're in externals/jellyfin-ffmpeg/builder)
          cd ../../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
          
      - name: Build Native Binary
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build using node-gyp directly (N-API ensures compatibility)
          npx node-gyp rebuild
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        run: |
          npm run test:all
        env:
          PKG_CONFIG_PATH: "/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        run: |
          mkdir -p artifacts
          artifact_name="node-av-linux-${{ matrix.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-linux-${{ matrix.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip

  build_windows:
    name: 'Windows ${{ matrix.os.arch }}'
    runs-on: ${{ matrix.os.runner }}
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        os:
          - arch: x64
            runner: windows-latest
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: true

      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          install: >-
            git
            curl
            wget
            zip
            patch
            diffutils
            quilt
            diffstat
            make
            cmake
            nasm
            ${{ matrix.os.toolchain }}
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-make
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-cmake
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-pkg-config
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-autotools

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Node Dependencies
        shell: bash
        run: |
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: ${{ matrix.os.msystem == 'CLANG64' && '/clang64/ffbuild' || '/clangarm64/ffbuild' }}
          key: ffmpeg-jellyfin-windows-${{ matrix.os.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v2
          restore-keys: |
            ffmpeg-jellyfin-windows-${{ matrix.os.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          # Prepare prefix dir exactly like Jellyfin does
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild
          
          # Update pacman database and retry on failures
          pacman -Syy --noconfirm || pacman -Syy --noconfirm
          
          cd externals/jellyfin-ffmpeg
          
          # Run Jellyfin's build script to build dependencies and configure FFmpeg
          ${{ matrix.os.build_script }}
          
          # IMPORTANT: build.sh or buildarm64.sh already ran configure + make
          # We just need to install libraries and headers
          echo "Installing FFmpeg libraries and headers..."
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            PREFIX="/clang64/ffbuild"
          else
            PREFIX="/clangarm64/ffbuild"
          fi
          
          # Install everything (make install is simpler and works)
          make install DESTDIR="" prefix="$PREFIX"
          
          cd ../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ${{ matrix.os.msystem == 'CLANG64' && '/clang64/ffbuild' || '/clangarm64/ffbuild' }}
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
      

      - name: Build Native Binary
        shell: msys2 {0}
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set environment for the correct architecture
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export PKG_CONFIG_PATH="/clang64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
            export CFLAGS="-I/clang64/ffbuild/include"
            export CXXFLAGS="-I/clang64/ffbuild/include"
            export LDFLAGS="-L/clang64/ffbuild/lib"
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export NM="llvm-nm"
          else
            export PKG_CONFIG_PATH="/clangarm64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
            export CFLAGS="-I/clangarm64/ffbuild/include"
            export CXXFLAGS="-I/clangarm64/ffbuild/include"
            export LDFLAGS="-L/clangarm64/ffbuild/lib"
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export NM="llvm-nm"
          fi
          
          # CRITICAL: Use MSYS2's pkg-config, not Strawberry Perl's
          export PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/bin:$PATH"
          which pkg-config
          pkg-config --version
          
          # Build using node-gyp with clang (not MSVC)
          npx node-gyp rebuild --verbose
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        shell: msys2 {0}
        run: |
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export PKG_CONFIG_PATH="/clang64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          else
            export PKG_CONFIG_PATH="/clangarm64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          fi
          npm run test:all

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        shell: bash
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        shell: bash
        run: |
          mkdir -p artifacts
          artifact_name="node-av-win32-${{ matrix.os.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-win32-${{ matrix.os.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip
