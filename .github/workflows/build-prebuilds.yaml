name: '🏗️ Build Prebuilds'

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
  workflow_call:

jobs:
  build_mac:
    name: 'macOS ${{ matrix.arch }}'
    runs-on: macos-13
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        include:
          - arch: x64
            target: mac64
          - arch: arm64
            target: macarm64
    
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Install Dependencies
        run: |
          # Install all dependencies required by Jellyfin's buildmac.sh
          brew install wget subversion mercurial autoconf automake cmake meson ninja pkg-config coreutils gcc make python-setuptools pcre2 libtool gnu-sed gnu-tar nasm yasm quilt texinfo
          # Ensure gsed is available (gnu-sed installs it as gsed)
          which gsed || brew link --force gnu-sed
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-jellyfin-macos-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v2
          restore-keys: |
            ffmpeg-jellyfin-macos-${{ matrix.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          # Prepare prefix dir exactly like Jellyfin does
          sudo mkdir -p /opt/ffbuild
          sudo chmod 777 /opt/ffbuild
          
          # CRITICAL: Create symlink because FFmpeg configure uses /ffbuild/prefix
          # but all libraries are installed to /opt/ffbuild/prefix
          # This is a quirk in Jellyfin's buildmac.sh script
          sudo ln -s /opt/ffbuild /ffbuild
          
          # Make helper scripts available in PATH (required by library build scripts)
          sudo mkdir -p /usr/local/bin
          for script in externals/jellyfin-ffmpeg/builder/images/base/*.sh; do
            if [ -f "$script" ]; then
              scriptname=$(basename "$script" .sh)
              sudo cp "$script" "/usr/local/bin/$scriptname"
              sudo chmod +x "/usr/local/bin/$scriptname"
            fi
          done
          
          # Run buildmac.sh from the jellyfin-ffmpeg root, exactly like Jellyfin does
          cd externals/jellyfin-ffmpeg
          
          # Map GitHub arch to Jellyfin arch
          if [ "${{ matrix.arch }}" = "x64" ]; then
            ./builder/buildmac.sh x86_64
          else
            ./builder/buildmac.sh arm64
          fi
          
          # IMPORTANT: Install FFmpeg properly instead of just building executables
          echo "Installing FFmpeg libraries and headers..."
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"
          
          # Verify installation
          echo "Verifying FFmpeg installation..."
          ls -la /opt/ffbuild/prefix/lib/*.a | head -5 || echo "No static libraries found!"
          ls -la /opt/ffbuild/prefix/include/ || echo "No headers found!"
          ls -la /opt/ffbuild/prefix/lib/pkgconfig/*.pc | head -5 || echo "No pkg-config files found!"
          
          cd ../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
      
      - name: Verify FFmpeg Installation
        run: |
          echo "Checking FFmpeg libraries..."
          ls -la /opt/ffbuild/prefix/lib/*.a | head -20 || echo "No libraries found!"
          echo ""
          echo "Checking pkg-config files..."
          ls -la /opt/ffbuild/prefix/lib/pkgconfig/*.pc | head -10 || echo "No pkg-config files found!"
          echo ""
          echo "Testing pkg-config..."
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig"
          pkg-config --exists libavcodec && echo "✓ libavcodec found" || echo "✗ libavcodec not found"
          pkg-config --exists libavformat && echo "✓ libavformat found" || echo "✗ libavformat not found"
          pkg-config --exists libavutil && echo "✓ libavutil found" || echo "✗ libavutil not found"
          pkg-config --exists libswscale && echo "✓ libswscale found" || echo "✗ libswscale not found"
          pkg-config --exists libswresample && echo "✓ libswresample found" || echo "✗ libswresample not found"
          
      - name: Build Native Binary
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build using node-gyp directly (N-API ensures compatibility)
          npx node-gyp rebuild
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        run: |
          npm run test:all
        env:
          PKG_CONFIG_PATH: "/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        run: |
          mkdir -p artifacts
          artifact_name="node-av-darwin-${{ matrix.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-darwin-${{ matrix.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip

  build_linux:
    name: 'Linux ${{ matrix.arch }}'
    runs-on: ubuntu-latest
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        include:
          - arch: x64
            target: linux64
          - arch: arm64
            target: linuxarm64
    
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: |
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: /opt/ffbuild/prefix
          key: ffmpeg-jellyfin-linux-${{ matrix.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v3
          restore-keys: |
            ffmpeg-jellyfin-linux-${{ matrix.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          cd externals/jellyfin-ffmpeg
          
          # Determine target architecture
          if [ "${{ matrix.arch }}" = "x64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi
          
          # Try to use pre-built Docker image from our registry
          OUR_IMAGE="ghcr.io/${{ github.repository }}-ffmpeg:${TARGET}-gpl"
          
          if docker pull "$OUR_IMAGE" 2>/dev/null; then
            echo "Using pre-built Docker image from our registry"
            
            # Extract development files from our Docker image
            CONTAINER_ID=$(docker create "$OUR_IMAGE")
            
            # Copy the entire prefix directory with libraries and headers
            sudo mkdir -p /opt/ffbuild/prefix
            docker cp "$CONTAINER_ID:/ffbuild/prefix/" /opt/ffbuild/
            docker rm "$CONTAINER_ID"
          else
            echo "No pre-built image found, building from scratch"
            
            # Build using Jellyfin's script which creates a Docker image locally
            cd builder
            ./makeimage.sh "$TARGET" gpl
            
            # The image is now tagged as ghcr.io/jellyfin/jellyfin-ffmpeg/${TARGET}-gpl:latest locally
            # Extract development files from it
            IMAGE_TAG="ghcr.io/jellyfin/jellyfin-ffmpeg/${TARGET}-gpl:latest"
            CONTAINER_ID=$(docker create "$IMAGE_TAG")
            
            # Copy the entire prefix directory with libraries and headers
            sudo mkdir -p /opt/ffbuild/prefix
            docker cp "$CONTAINER_ID:/ffbuild/prefix/" /opt/ffbuild/
            docker rm "$CONTAINER_ID"
            
            # Also create the portable binaries
            ./build.sh "$TARGET" gpl
            mkdir -p ../../bin
            mv artifacts/jellyfin-ffmpeg*portable_${TARGET}-gpl*.tar.xz ../../bin/ || true
            
            cd ..
          fi
          
          cd ../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /opt/ffbuild/prefix
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
          
      - name: Verify FFmpeg Libraries
        run: |
          # Verify that the development files are available
          ls -la /opt/ffbuild/prefix/include/ | head -20
          ls -la /opt/ffbuild/prefix/lib/ | head -20
          pkg-config --exists libavcodec || echo "Warning: pkg-config files may not be properly configured"
          
      - name: Build Native Binary
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          export PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"
          export CFLAGS="-I/opt/ffbuild/prefix/include"
          export CXXFLAGS="-I/opt/ffbuild/prefix/include"
          export LDFLAGS="-L/opt/ffbuild/prefix/lib"
          
          # Build using node-gyp directly (N-API ensures compatibility)
          npx node-gyp rebuild
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        run: |
          npm run test:all
        env:
          PKG_CONFIG_PATH: "/opt/ffbuild/prefix/lib/pkgconfig:${PKG_CONFIG_PATH}"

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        run: |
          mkdir -p artifacts
          artifact_name="node-av-linux-${{ matrix.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-linux-${{ matrix.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip

  build_windows:
    name: 'Windows ${{ matrix.os.arch }}'
    runs-on: ${{ matrix.os.runner }}
    # Skip this job if it's a tag push (handled by build-prebuilds-publish.yaml)
    if: github.event_name != 'push' || !startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        os:
          - arch: x64
            runner: windows-latest
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          install: >-
            git
            curl
            wget
            zip
            patch
            diffutils
            quilt
            diffstat
            make
            cmake
            nasm
            ${{ matrix.os.toolchain }}
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-make
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-cmake
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-pkg-config
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-autotools

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Node Dependencies
        shell: bash
        run: |
          npm ci --ignore-scripts
          npm install --no-save node-gyp

      - name: Restore FFmpeg Libraries Cache
        id: cache-ffmpeg-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /clang64/ffbuild
            /clangarm64/ffbuild
          key: ffmpeg-jellyfin-windows-${{ matrix.os.arch }}-${{ hashFiles('externals/jellyfin-ffmpeg/**') }}-v1
          restore-keys: |
            ffmpeg-jellyfin-windows-${{ matrix.os.arch }}-
      
      - name: Build FFmpeg Libraries
        id: build-ffmpeg
        if: steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        run: |
          # Prepare prefix dir exactly like Jellyfin does
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild
          
          # Update pacman database and retry on failures
          pacman -Syy --noconfirm || pacman -Syy --noconfirm
          
          cd externals/jellyfin-ffmpeg
          
          # Run Jellyfin's build script to build dependencies and configure FFmpeg
          ${{ matrix.os.build_script }}
          
          # IMPORTANT: Install FFmpeg properly instead of just building executables
          # This ensures all libraries, headers, and pkg-config files are in the right place
          echo "Installing FFmpeg libraries and headers..."
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            PREFIX="/clang64/ffbuild"
          else
            PREFIX="/clangarm64/ffbuild"
          fi
          
          # Run make install to properly install everything
          make install DESTDIR="" prefix="$PREFIX"
          
          cd ../..
      
      - name: Save FFmpeg Libraries Cache
        if: steps.build-ffmpeg.outcome == 'success' && steps.cache-ffmpeg-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            /clang64/ffbuild
            /clangarm64/ffbuild
          key: ${{ steps.cache-ffmpeg-restore.outputs.cache-primary-key }}
      
      - name: Verify FFmpeg Installation
        shell: bash
        run: |
          echo "=== Verifying FFmpeg Installation ==="
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            PREFIX="/clang64/ffbuild"
          else
            PREFIX="/clangarm64/ffbuild"
          fi
          
          echo "Checking libraries in $PREFIX/lib/..."
          if [ -f "$PREFIX/lib/libavcodec.a" ]; then
            ls -la "$PREFIX/lib/"*.a | head -10
            echo "✓ FFmpeg static libraries found"
          else
            echo "✗ FFmpeg static libraries NOT found!"
            exit 1
          fi
          
          echo ""
          echo "Checking headers in $PREFIX/include/..."
          if [ -d "$PREFIX/include/libavcodec" ]; then
            ls -la "$PREFIX/include/" | head -10
            echo "✓ FFmpeg headers found"
          else
            echo "✗ FFmpeg headers NOT found!"
            exit 1
          fi
          
          echo ""
          echo "Checking pkg-config files in $PREFIX/lib/pkgconfig/..."
          if [ -f "$PREFIX/lib/pkgconfig/libavcodec.pc" ]; then
            ls -la "$PREFIX/lib/pkgconfig/"*.pc | head -10
            echo "✓ pkg-config files found"
          else
            echo "✗ pkg-config files NOT found!"
            exit 1
          fi

      - name: Build Native Binary
        shell: msys2 {0}
        run: |
          # Use Jellyfin binding configuration
          cp binding-jellyfin.gyp binding.gyp
          
          # Set environment for the correct architecture
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export PKG_CONFIG_PATH="/clang64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
            export CFLAGS="-I/clang64/ffbuild/include"
            export CXXFLAGS="-I/clang64/ffbuild/include"
            export LDFLAGS="-L/clang64/ffbuild/lib"
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export NM="llvm-nm"
          else
            export PKG_CONFIG_PATH="/clangarm64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
            export CFLAGS="-I/clangarm64/ffbuild/include"
            export CXXFLAGS="-I/clangarm64/ffbuild/include"
            export LDFLAGS="-L/clangarm64/ffbuild/lib"
            export CC="clang"
            export CXX="clang++"
            export AR="llvm-ar"
            export NM="llvm-nm"
          fi
          
          # CRITICAL: Use MSYS2's pkg-config, not Strawberry Perl's
          export PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/bin:$PATH"
          which pkg-config
          pkg-config --version
          
          # Build using node-gyp with clang (not MSVC)
          npx node-gyp rebuild --verbose
          
          # Move binary to expected location
          mkdir -p build
          cp build/Release/node-av.node build/node-av.node

      - name: Run Tests
        shell: msys2 {0}
        run: |
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            export PKG_CONFIG_PATH="/clang64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          else
            export PKG_CONFIG_PATH="/clangarm64/ffbuild/lib/pkgconfig:${PKG_CONFIG_PATH}"
          fi
          npm run test:all

      - name: Get Package Version
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        shell: bash
        id: version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Package Binary
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        shell: bash
        run: |
          mkdir -p artifacts
          artifact_name="node-av-win32-${{ matrix.os.arch }}-${{ steps.version.outputs.version }}.zip"
          (cd build && zip -j "../artifacts/${artifact_name}" node-av.node)
          ls -la artifacts/

      - name: Upload Artifacts
        if: github.event_name == 'workflow_call' || startsWith(github.ref, 'refs/tags/v')
        uses: actions/upload-artifact@v4
        with:
          name: node-av-win32-${{ matrix.os.arch }}-${{ steps.version.outputs.version }}
          path: artifacts/*.zip
